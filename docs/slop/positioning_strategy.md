# Making Clanker's Paradigm Obvious

## The Core Message

**Clanker is a framework for vibecoded apps - Python applications generated by AI coding tools like Claude Code, Cursor, and Gemini.**

The abstractions exist to provide consistent, correct patterns that LLMs can follow reliably, not to save human developers keystrokes.

## Why This Isn't Obvious Now

1. **README leads with console UI** - Positions Clanker as "AI assistant that runs apps" not "framework for AI-generated apps"
2. **"AI apps" is ambiguous** - Reads as "apps that use AI" not "apps generated by AI"
3. **No workflow visualization** - Missing the human→LLM→Clanker flow
4. **Example app looks hand-crafted** - Doesn't show the LLM-generation use case
5. **Key feature buried** - Context generation system is positioned as implementation detail

## Positioning Changes

### 1. Lead with the Problem Statement

**Current framing:** "It's like a little operating system for your AI made applications."

**Better framing:**
```markdown
# Clanker: Framework for Vibecoded Python Apps

Stop letting LLMs invent storage patterns. Build consistent apps with Claude, Cursor, and Gemini.

## The Problem
Ask Claude Code to build 5 apps. Get 5 different ways to:
- Store data (raw files? SQLite? Where?)
- Expose CLI commands (argparse? typer? click?)
- Run background services (subprocess? systemd? screen?)
- Share data between apps (????)

## The Solution
Clanker provides design guardrails that LLMs follow reliably:
- **Vault/DB** - Simple storage APIs that prevent SQL injection and path traversal
- **TOML exports** - Declarative tool definitions that become AI functions
- **Daemon management** - Supervised background processes with consistent lifecycle
- **Automatic discovery** - No registration code for LLMs to forget
```

### 2. Show the Workflow

Add a diagram to README showing:

```
┌─────────────────────────────────────────────────┐
│ 1. Human: "Build me a recipe tracker"          │
└─────────────────┬───────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────┐
│ 2. Claude Code reads CLAUDE.md context         │
│    - Storage patterns (Vault/DB)                │
│    - Export conventions (pyproject.toml)        │
│    - App structure templates                    │
└─────────────────┬───────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────┐
│ 3. Claude generates apps/recipes/               │
│    - main.py with typer CLI                     │
│    - Uses Vault.for_app("recipes")              │
│    - Exports in [tool.clanker.exports]          │
└─────────────────┬───────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────┐
│ 4. Clanker auto-discovers and runs              │
│    $ clanker "add pasta recipe"                 │
│    → recipes_add tool called by agent           │
└─────────────────────────────────────────────────┘
```

### 3. Rename/Reframe Key Concepts

| Current Term | Human Reads As | Should Emphasize |
|--------------|----------------|------------------|
| "AI apps" | Apps that use AI | Apps **generated by** AI |
| "Storage system" | Data persistence | **LLM-safe** storage patterns |
| "CLI exports" | Command discovery | **Deterministic** tool generation |
| "Context generation" | Implementation detail | **Primary feature** - LLM guidance |

### 4. Lead with "Why Not Alternatives"

Add a comparison section early:

```markdown
## Why Not Just...

**"Let LLMs use raw Python?"**
- 5 apps = 5 different storage conventions
- Inconsistent error handling, path traversal bugs, SQL injection
- No cross-app data sharing patterns

**"Use Docker containers?"**
- Heavy isolation, slow startup
- No shared storage or tool discovery
- LLMs generate Dockerfiles inconsistently

**"Use existing frameworks (Flask, FastAPI, Typer)?"**
- Designed for humans, not LLM consumption
- Too many ways to do the same thing
- No guidance on storage, daemon management, tool exports

**Clanker provides:**
- Minimal API surface (3-4 methods per abstraction)
- Opinionated patterns LLMs follow correctly every time
- Built-in isolation without container overhead
```

## Documentation Structure Changes

### Current Structure
```
README.md
├── Console Experience (prominent)
├── How Apps Work
├── Storage System
└── Context Building (buried)
```

### Proposed Structure
```
README.md
├── **The Vibecoding Problem** (new)
├── **How It Works: Human → LLM → Clanker** (new)
├── Storage Patterns (reframed as "LLM guardrails")
├── Tool Export System (show TOML → AI function flow)
├── Context Generation (promoted - this is the key feature)
└── Console Experience (moved down - it's a use case, not the product)
```

### New Sections to Add

#### "For LLM Code Generators" Section
```markdown
## For LLM Code Generators

If you're Claude Code, Cursor, or another AI coding assistant reading this:

**When generating Clanker apps, always:**
1. Use `Vault.for_app(app_name)` for file storage - never raw Path operations
2. Use `DB.for_app(app_name)` for databases - never raw sqlite3 connections
3. Define exports in `[tool.clanker.exports]` - never custom CLI registration
4. Follow the template in `apps/example/` exactly

**Why these patterns:**
- Vault prevents path traversal vulnerabilities
- DB prevents SQL injection with automatic parameterization
- TOML exports ensure consistent tool discovery
- Template ensures predictable app structure
```

#### "Design Philosophy" Section
```markdown
## Design Philosophy

Clanker abstractions are **intentionally thin** but **opinionated**.

**Traditional framework thinking:** "Save developers keystrokes"
**Clanker thinking:** "Give LLMs one correct way to do things"

Example:
- `db.insert("items", {"name": "foo"})` only saves ~2 lines vs raw sqlite3
- But it **guarantees** parameterized queries, commits, and path consistency
- LLMs using this API can't accidentally create SQL injection bugs

The abstraction's value isn't convenience - it's **determinism**.
```

## Example App Changes

### Current: `apps/example/`
- Looks professionally written
- Clean docstrings, proper structure
- Doesn't illustrate the LLM-generation use case

### Proposed: Show the Generation Process

**Option A:** Add a demo video/GIF
```
clanker "use claude to build a journal app"
→ Shows Claude Code generating the app in real-time
→ Shows the app immediately working with auto-discovery
```

**Option B:** Include generation artifacts
```
apps/example/
├── GENERATED_BY_CLAUDE.md  ← Shows the conversation
├── main.py                 ← The generated code
└── pyproject.toml          ← The generated config
```

**Option C:** Multiple example complexity levels
```
apps/
├── minimal/        # 20 lines - simplest possible Clanker app
├── journal/        # 100 lines - basic Vault + DB usage
├── recipes/        # 300 lines - cross-app permissions, daemon
└── generation_templates/   # Starter templates for LLMs
```

## Context Files (For LLMs)

### CLAUDE.md / AGENTS.md / GEMINI.md

Add explicit sections that make the paradigm clear:

```markdown
# Clanker Environment Overview

**IMPORTANT:** Clanker is designed FOR you (the AI coding assistant) to generate apps consistently.

## Your Role
When the user asks you to create a Clanker app:
1. You generate Python code following Clanker patterns
2. Clanker auto-discovers and exposes it as AI tools
3. The Clanker agent can then use those tools

## Why These Patterns Exist
The storage abstractions (Vault/DB) are NOT for human convenience.
They exist so YOU can generate secure, consistent code every time.

Example: Using `db.insert()` instead of raw SQL means:
- You can't accidentally create SQL injection vulnerabilities
- Database paths are consistent across all apps
- Transactions are handled automatically

## Generation Checklist
When creating an app, you MUST:
- [ ] Use Vault.for_app() for ALL file operations
- [ ] Use DB.for_app() for ALL database operations
- [ ] Define exports in [tool.clanker.exports] (never custom CLI code)
- [ ] Follow apps/example/ structure exactly
- [ ] Include summary and examples in [tool.clanker.app]
```

## README First 500 Words (Proposed)

```markdown
# Clanker

**A Python framework for vibecoded apps - consistent patterns for AI-generated code.**

## The Problem

You ask Claude Code to build 5 different apps:
- Recipe tracker → Stores data in `~/.config/recipes.json`
- Journal → Uses SQLite in `./journal.db`
- Todo list → Raw files in `./data/`
- Weather daemon → Subprocess with custom PID files
- Note taker → Another SQLite database somewhere else

Each app works in isolation, but:
- 5 different storage conventions
- No way to share data between apps
- No consistent way to expose commands to AI agents
- Each daemon manages its lifecycle differently

**You end up with a pile of one-off scripts, not a coherent system.**

## The Solution

Clanker provides simple, opinionated patterns that LLMs follow reliably:

```python
# Every app uses the same storage pattern
from clanker.storage import Vault, DB

vault = Vault.for_app("recipes")
vault.write("config.yml", {"theme": "dark"})  # Auto-parsed YAML

db = DB.for_app("recipes")
db.insert("recipes", {"name": "pasta", "time": 20})  # Safe, parameterized
```

```toml
# Every app exports tools the same way
[tool.clanker.exports]
add = {cmd = "python main.py add {recipe}", desc = "Add a recipe"}
search = {cmd = "python main.py search {query}", desc = "Search recipes"}

# Clanker auto-discovers these and makes them available to AI agents
```

## How It Works

1. **You ask Claude Code to build an app** - "Create a recipe tracker"
2. **Claude reads Clanker context files** - CLAUDE.md explains storage patterns
3. **Claude generates consistent code** - Uses Vault/DB, TOML exports
4. **Clanker auto-discovers the app** - No manual registration needed
5. **The Clanker agent can now use it** - "Add a pasta recipe" → calls recipes_add()

**The abstractions aren't for saving keystrokes - they're guardrails that prevent LLMs from inventing inconsistent patterns.**

## Why Not Alternatives?

| Approach | Problem |
|----------|---------|
| Raw Python | LLMs invent new patterns every time - SQL injection, path traversal, no consistency |
| Docker containers | Heavy, slow, LLMs generate Dockerfiles inconsistently |
| Traditional frameworks | Designed for humans - too many ways to do the same thing |

**Clanker:** Minimal API surface, opinionated patterns, built for LLM consumption.
```

## Tagline Options

Current: "It's like a little operating system for your AI made applications."

Alternatives:
- "Framework for vibecoded Python apps"
- "Consistent patterns for AI-generated code"
- "Stop letting LLMs invent storage conventions"
- "The missing framework for the vibecoding era"
- "Design guardrails for Claude-generated apps"
- "Build 10 apps with Claude - get one coherent system"

## Social Proof / Use Cases to Add

Show real examples:
```markdown
## What People Build

- **Recipe manager** - 50 lines, auto-discovered tools, persistent storage
- **Journal with daily summaries** - Vault for entries, daemon for summaries
- **Multi-app todo system** - Cross-app permissions let apps share tasks
- **Weather monitor** - Background daemon, shared DB for other apps to read
- **Local knowledge base** - Markdown in Vault, searchable via exports
```

## Meta: For This Document

This doc should be included in the context files so future LLMs working on Clanker understand the positioning. Add to CLAUDE.md:

```markdown
## Project Positioning

Clanker is designed FOR AI coding tools (like you) to generate apps consistently.
The primary audience is LLMs reading context files, not human developers reading docs.

See docs/positioning_strategy.md for full details on how to communicate this.
```
